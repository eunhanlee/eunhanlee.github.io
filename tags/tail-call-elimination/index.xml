<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tail call elimination on Eunhan's library</title><link>https://eunhanlee.github.io/tags/tail-call-elimination/</link><description>Recent content in tail call elimination on Eunhan's library</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; 2021. All rights reserved.</copyright><lastBuildDate>Wed, 21 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://eunhanlee.github.io/tags/tail-call-elimination/index.xml" rel="self" type="application/rss+xml"/><item><title>tail call elimination</title><link>https://eunhanlee.github.io/post/tail-call-elimination/</link><pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate><guid>https://eunhanlee.github.io/post/tail-call-elimination/</guid><description>Definition When there is recursion, the recursive class remain in stack memory and it will cause overflow. The tail call elimination is created for fixing the overflow issue. If the reucursive class return everything at last, the class does need to remain in stack memory.
Other Names tail call elimination tail call optimization tail call elimination providers Currently(4/21/2021), some languages provide this function and some are not.
Java: No.</description></item></channel></rss>