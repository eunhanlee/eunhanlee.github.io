<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MergeSort on Eunhan's library</title><link>https://eunhanlee.github.io/tags/mergesort/</link><description>Recent content in MergeSort on Eunhan's library</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; 2021. All rights reserved.</copyright><lastBuildDate>Thu, 30 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://eunhanlee.github.io/tags/mergesort/index.xml" rel="self" type="application/rss+xml"/><item><title>Merge Sort</title><link>https://eunhanlee.github.io/post/merge-sort/</link><pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate><guid>https://eunhanlee.github.io/post/merge-sort/</guid><description>Definition one of sort algorithms
Technique Decrease and Conquer
Algorithm steps Recusively loop
Recusively loop left side and right side until the input array cannot separated every separated parts only one element is in there. This is sorted. merge arrays with sort. Java code public static void mergeSort(int[] input) { mergeSortRecurr(input, 0, input.length - 1); } public static void mergeSortRecurr(int[] input, int left, int right) { if (left &amp;lt; right) { int midPos = left + (right - left) / 2; mergeSortRecurr(input, left, midPos); mergeSortRecurr(input, midPos + 1, right); merge(input, left, right, midPos); } } public static void merge(int[] input, int left, int right, int midPos) { //mid pos does not check unlike the left and right int temp1 = midPos - left + 1; int temp2 = right - midPos; //temp array and copy int[] L = new int[temp1]; int[] R = new int[temp2]; for (int i = 0; i &amp;lt; temp1; ++i) L[i] = input[left + i]; for (int j = 0; j &amp;lt; temp2; ++j) R[j] = input[midPos + 1 + j]; int i = 0; int j = 0; int k = left; while (i &amp;lt; temp1 &amp;amp;&amp;amp; j &amp;lt; temp2) { if (L[i] &amp;lt;= R[j]) { input[k] = L[i]; ++i; } else { input[k] = R[j]; ++j; } ++k; } while (i &amp;lt; temp1) { input[k] = L[i]; ++i; ++k; } while (j &amp;lt; temp2) { input[k] = R[j]; ++j; ++k; } } Avg.</description></item></channel></rss>