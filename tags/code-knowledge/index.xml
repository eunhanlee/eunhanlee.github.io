<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>code knowledge on Eunhan's library</title><link>https://eunhanlee.github.io/tags/code-knowledge/</link><description>Recent content in code knowledge on Eunhan's library</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; 2021. All rights reserved.</copyright><lastBuildDate>Wed, 21 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://eunhanlee.github.io/tags/code-knowledge/index.xml" rel="self" type="application/rss+xml"/><item><title>[Java]Stringbuilder</title><link>https://eunhanlee.github.io/post/javastringbuilder/</link><pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate><guid>https://eunhanlee.github.io/post/javastringbuilder/</guid><description>Definition StringBuilder class is for attach additional strings after you created the String.
Why should we use Stringbuilder? We can add Strings various ways.
concat : word.concat(&amp;quot;add&amp;quot;); using &amp;ldquo;+&amp;rdquo; : word += &amp;quot;add&amp;quot;; However, String is object and it is immutable. What happen in computer is make another space and copy and paste the original string and add new strings. If we change the string more than 1000 times, it will be slow and waste memory.</description></item><item><title>Divide and conquer strategy</title><link>https://eunhanlee.github.io/post/divide-and-conquer-strategy/</link><pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate><guid>https://eunhanlee.github.io/post/divide-and-conquer-strategy/</guid><description>Purpose split problem into sub problems as much as possible and merge all of them to answer
Divide and conquer algorithms vs. Dynamic programming? Divide and conquer algorithms does not use subproblems&amp;rsquo; results for other sub problems.
But, dynamic programming uses other resoults of subproblem.
Usually use in.. quick sort merge sort binary sort Fast Fourier Transform (FFT) big data analysis Explanation divide: separate problems that are smaller instances of the same problem conquer: solve the subprolems recursively merge: add all of subanswers to find answer Example merge sort step 1.</description></item><item><title>tail call elimination</title><link>https://eunhanlee.github.io/post/tail-call-elimination/</link><pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate><guid>https://eunhanlee.github.io/post/tail-call-elimination/</guid><description>Definition When there is recursion, the recursive class remain in stack memory and it will cause overflow. The tail call elimination is created for fixing the overflow issue. If the reucursive class return everything at last, the class does need to remain in stack memory.
Other Names tail call elimination tail call optimization tail call elimination providers Currently(4/21/2021), some languages provide this function and some are not.
Java: No.</description></item><item><title>Kadane's Algorithm</title><link>https://eunhanlee.github.io/post/kadanes-algorithm/</link><pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate><guid>https://eunhanlee.github.io/post/kadanes-algorithm/</guid><description>Purpose Find maximum sum of contiguous values in an array. The array order must not change.
Example If there is $[-2, 1, -3, 4, -1, 2, 1, -5, 4] $
$[4, -1, 2, 1]$ is the answer
4+(-1)+2+1=6, this is bigger than any other contiguous values.
Complexity Analysis Time complexity : $O(N)$ since it&amp;rsquo;s one pass along the array. Space complexity : $O(1)$, since it&amp;rsquo;s a constant space solution. Explanation For finding maxium number, we need to calculate all of possible numbers and compare.</description></item><item><title>what is hashmap in Java</title><link>https://eunhanlee.github.io/post/hashmap/</link><pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate><guid>https://eunhanlee.github.io/post/hashmap/</guid><description>Definition Hashmap basically solves the problem of searching objects from large set.
When should we use it large set of objects frequent access to objects required. methods method result time complexity HashMap&amp;lt;String,String&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); create hashmap constructor put( key, value ) add key and value usually O(1) remove( key ) remove the key usually O(1) get( key ) get value from the key usually O(1) isEmpty() T or F for all data O(n) size() return how may keys O(n) containsKey( key ) check key is there usually O(1) containsValue( value ) check value is there usually O(1) getOrDefault( key, value) get value from the key.</description></item><item><title>what is comparable in Java</title><link>https://eunhanlee.github.io/post/javacomparable/</link><pubDate>Wed, 14 Apr 2021 00:00:00 +0000</pubDate><guid>https://eunhanlee.github.io/post/javacomparable/</guid><description>Hierarchy package: java.lang.Comparable
Definition Sorting interface that designed for a condition by overriding compareTo method. For example, you can sort list in ascending order of size.
about the compareTo() method if compareTo() method return positive number, swap the input parameters
else will be remain same
condition return First parameter &amp;lt; second parameter negative First parameter == second parameter 0 First parameter &amp;gt; second parameter positive How to use customObject implements Comparable&amp;lt;&amp;gt;</description></item><item><title>what is comparator in Java</title><link>https://eunhanlee.github.io/post/javacomparator/</link><pubDate>Wed, 14 Apr 2021 00:00:00 +0000</pubDate><guid>https://eunhanlee.github.io/post/javacomparator/</guid><description>Hierarchy package: java.util.Comparator
Definition Sorting interface that designed for mutiple conditions by creating compare method. For example, you can sort list in ascending order of size and descending order of letters.
about the compare() method if compare() method return positive number, swap the input parameters
else will be remain same
condition return First parameter &amp;lt; second parameter negative First parameter == second parameter 0 First parameter &amp;gt; second parameter positive How to use MyComparator implements Comparator&amp;lt;&amp;gt;</description></item><item><title>what is iterator in Java</title><link>https://eunhanlee.github.io/post/javaiterator/</link><pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate><guid>https://eunhanlee.github.io/post/javaiterator/</guid><description>Definition Interface that can read any class in the collection framework.
Thus, we can read arraylist or linkedlist or hashmap with iterator.
why we use iterator? Since we can read any list or set with iterator, we do not have to fix or change code when you work with big projects.
Hierarchy method hasNext() next() remove()
Example List list = new ArrayList();// arrayList list.add(&amp;#34;1&amp;#34;); list.add(&amp;#34;2&amp;#34;); list.add(&amp;#34;3&amp;#34;); Iterator &amp;lt;string&amp;gt; itr = list.</description></item><item><title>[Java]Primitive type and Reference type</title><link>https://eunhanlee.github.io/post/javaprimitive-type-and-reference-type/</link><pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate><guid>https://eunhanlee.github.io/post/javaprimitive-type-and-reference-type/</guid><description>Primitive type JAVA provides 8 kinds of Primitive type There is no null value. Defult value is already inserted. actual value will saved in Stack memory. String is object. Not primitive type. Data Type Allocated Memory Defult Value Range of Data Range of Data in Number boolean 1 byte false true, false byte 1 byte 0 -127 ~ 128 $-2^{7}$~ $(2^{7}-1)$ short 2 byte 0 -32,768 ~ 32,767 $-2^{15}$~ $(2^{15}-1)$ int 4 byte 0 -2,147,483,648 ~ 2,147,483,647 $-2^{31}$~ $(2^{31}-1)$ long 8 byte 0L -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 $-2^{63}$~ $(2^{63}-1)$ float 4 byte 0.</description></item><item><title>Fibonacci sequence</title><link>https://eunhanlee.github.io/post/fibonacci-sequence/</link><pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate><guid>https://eunhanlee.github.io/post/fibonacci-sequence/</guid><description>Definition Certain patterns of numbers.
first and second numbers are always 0,1. next number is addition of previous two numbers
Recurrence Relation $F_0=0$
$F_1=1$
$F_n=F_{n-1}+F_{n-2}$
Example index fibonacci numbers calculation 0 0 0 1 1 1 2 1 0+1 3 2 1+1 4 3 1+2 5 5 2+3 6 8 3+5 7 13 5+8 8 21 8+13 9 34 13+21 10 55 21+34 11 89 34+55 12 144 55+89 13 233 89+144 14 377 144+233 15 610 233+377 16 987 377+610 get nth fibonacci number math public static int fib(int num) { double goldenRatio = (1 + Math.</description></item><item><title>Dynamic Programming</title><link>https://eunhanlee.github.io/post/dynamic-programming/</link><pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate><guid>https://eunhanlee.github.io/post/dynamic-programming/</guid><description>Definition algorithmic problem solving technique that split into many simple subproblems and reduce steps of subproblems. In other wards, separates into subproblems and get solution by addition of all subproblems.
Example if you calculate $2^1+2^2+2^3+2^4+2^5$ and display each numbers,
$2^1=2=2$
$2^2=2+2=2^1+2$
$2^3=2+2+2=2^2+2$
$2^4=2+2+2+2=2^3+2$
$2^5=2+2+2+2+2=2^4+2$
since you need to calculate each of numbers ($2^1,2^2,2^3,2^4,2^5$), you can skip some of parts that you already calculated. When you calculate the $2^5$, you done have to calculate $2^4$ if that number $2^4$ is already calculated.</description></item><item><title>inclusive and exclusive</title><link>https://eunhanlee.github.io/post/inclusive-and-exclusive/</link><pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate><guid>https://eunhanlee.github.io/post/inclusive-and-exclusive/</guid><description>Inclusive - Including the last number
Exclusive - Excluding the last number
In Computer Science, inclusive/exclusive apply to a number range
Example inclusive If a function will compute \(2^i\) where \(i = 1, 2, ..., n\).
\(i\) can have values from 1 up to and including the value n.
We says, n is Included in Inclusive
1 through 10 (inclusive) = [1, 10] 1 2 3 4 5 6 7 8 9 10 exclusive If a function will compute $2^i$ where i = 1, 2, .</description></item></channel></rss>