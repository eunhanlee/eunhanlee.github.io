<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HeapSort on Eunhan's library</title><link>https://eunhanlee.github.io/tags/heapsort/</link><description>Recent content in HeapSort on Eunhan's library</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; 2021. All rights reserved.</copyright><lastBuildDate>Fri, 01 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://eunhanlee.github.io/tags/heapsort/index.xml" rel="self" type="application/rss+xml"/><item><title>Heap Sort</title><link>https://eunhanlee.github.io/post/heap-sort/</link><pubDate>Fri, 01 Oct 2021 00:00:00 +0000</pubDate><guid>https://eunhanlee.github.io/post/heap-sort/</guid><description>Definition one of sort array data structure based on binary tree insert data into binary tree and print out from the tree Algorithm steps insert data into binary tree The data sorted as binary tree print Java code public static void heapSort(int arr[]) { int n = arr.length; // Build heap (rearrange array) for (int i = n / 2 - 1; i &amp;gt;= 0; i--) heapTree(arr, n, i); // One by one extract an element from heap for (int i = n - 1; i &amp;gt; 0; i--) { // Move current root to end int temp = arr[0]; arr[0] = arr[i]; arr[i] = temp; // call max heapify on the reduced heap heapTree(arr, i, 0); } } // To heapify a subtree rooted with node i which is // an index in arr[].</description></item></channel></rss>