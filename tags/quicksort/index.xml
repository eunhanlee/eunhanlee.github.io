<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>QuickSort on Eunhan's library</title><link>https://eunhanlee.github.io/tags/quicksort/</link><description>Recent content in QuickSort on Eunhan's library</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; 2021. All rights reserved.</copyright><lastBuildDate>Tue, 21 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://eunhanlee.github.io/tags/quicksort/index.xml" rel="self" type="application/rss+xml"/><item><title>Quick Sort</title><link>https://eunhanlee.github.io/post/quick-sort/</link><pubDate>Tue, 21 Sep 2021 00:00:00 +0000</pubDate><guid>https://eunhanlee.github.io/post/quick-sort/</guid><description>Definition one of sort algorithms
The most important sort algorithm Use this algorithm anywhere with any languages The best way to avoid worst time complexity is pick pivot randomly. if program most not have $O(n^2)$, need to use other sorting algorithm. Technique Decrease and Conquer
Algorithm steps Recusively loop based on Lomuto.
pick pivot the most right element. left side will be smaller than pivot value and right side will be bigger than pivot.</description></item></channel></rss>